//======================================================================================================================

#include <thread>
#include <algorithm>
#include <exception>
#include <iostream>
#include <map>
#include <array>
#include <string>
using namespace std;

//======================================================================================================================

#define _TCHAR_DEFINED
#ifdef UNICODE
	#define _T(x) L ##x
	#define TCHAR wchar_t
#else
	#define _T(x) x
	#define TCHAR char
#endif
typedef basic_string<TCHAR> tstring;
typedef unsigned char ubyte;

//======================================================================================================================

#include <Poco/DirectoryIterator.h>
#include <Poco/String.h>
#include <Poco/StringTokenizer.h>
#include <Poco/Util/Application.h>
#include <Poco/Thread.h>
using namespace Poco;
using namespace Poco::Util;

//======================================================================================================================

class PipeShellApplication : public Application {
public:
	PipeShellApplication(int argc, char* argv[]) : Application(argc, argv) {}
	~PipeShellApplication() {}
};

//======================================================================================================================

#include <libpipe/LibPipeInstance.h>

//======================================================================================================================

int main(int argc, char* argv[]) {
	try {
		// Get application path
		PipeShellApplication self(argc, argv);
		Path commandPath(self.commandPath());

		auto appPath = commandPath.parent().toString();
		auto userPath = appPath + _T("PipeShellData");

		LibPipeInstance::loadExtensions(appPath);
		auto serviceTypes = LibPipeInstance::serviceTypes();

		LibPipeInstance pipe(userPath, serviceTypes);

		// Create instance
		cout << _T("------------------------------------------") << endl;
		cout << _T("Welcome to pipe shell") << endl;
		cout << _T("------------------------------------------") << endl;
		cout << _T("Available service types: ") << endl;
		for(auto& serviceType : serviceTypes) {
			cout << _T('\t') << serviceType << endl;
		}
		cout << _T("------------------------------------------") << endl;
		cout << endl;

		bool exit = false;

		thread receive([&]() {
			while(!exit) {
				/* TODO
				auto messages = pipe.receive();
				for(auto& message: messages) {
					cout << message.address << _T(" ") << message.type;
					for(auto& parameter : message.parameters) {
						cout << _T(" ") << parameter;
					}
					cout << endl;
				}
				*/
				Thread::sleep(100);
			}
		});

		thread send([&]() {
			const unsigned int bufferSize = 2048;
			TCHAR buffer[bufferSize];

			while(!exit) {
				cin.getline(buffer, bufferSize, _T('\n'));

				tstring message(buffer);

				if(message.compare(_T("exit")) == 0) {
					exit = true;
					continue;
				}

				StringTokenizer tokens(message, _T(" "), StringTokenizer::TOK_IGNORE_EMPTY);
				/* TODO
				LibPipeMessage pipeMessage;

				size_t idxToken = 0;
				for(auto& token : tokens) {
					if(idxToken == 0)
						pipeMessage.address = token;

					else if(idxToken == 1)
						pipeMessage.type = token;

					else
						pipeMessage.parameters.push_back(token);

					idxToken++;
				}

<<<<<<< HEAD
				pipe.send({ pipeMessage });
				*/
=======
				pipe.send(pipeMessage);
>>>>>>> ab95d46e279562f37a88e787b3c622bb8dbb7605
			}
		});

		while(!exit) {
			Thread::sleep(1000);
		}

		receive.join();
		send.join();
	}
	catch(exception e) {
		cout << _T("Exception: ") << e.what() << endl;
	}

	return 0;
}
