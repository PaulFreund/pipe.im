/*

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*/

module derelict.glib.gasyncqueue;

import derelict.glib.gtypes;
import derelict.glib.glibconfig;
import core.stdc.config;

extern (C):

alias _GAsyncQueue GAsyncQueue;

struct _GAsyncQueue;

extern( C ) nothrow 
{
    alias da_g_async_queue_new = GAsyncQueue* function();																								
    alias da_g_async_queue_new_full = GAsyncQueue* function(GDestroyNotify item_free_func);																
    alias da_g_async_queue_lock = void function(GAsyncQueue* queue);																					
    alias da_g_async_queue_unlock = void function(GAsyncQueue* queue);																					
    alias da_g_async_queue_ref = GAsyncQueue* function(GAsyncQueue* queue);																				
    alias da_g_async_queue_unref = void function(GAsyncQueue* queue);																					
    alias da_g_async_queue_ref_unlocked = void function(GAsyncQueue* queue);																			
    alias da_g_async_queue_unref_and_unlock = void function(GAsyncQueue* queue);																		
    alias da_g_async_queue_push = void function(GAsyncQueue* queue, gpointer data);																		
    alias da_g_async_queue_push_unlocked = void function(GAsyncQueue* queue, gpointer data);															
    alias da_g_async_queue_push_sorted = void function(GAsyncQueue* queue, gpointer data, GCompareDataFunc func, gpointer user_data);					
    alias da_g_async_queue_push_sorted_unlocked = void function(GAsyncQueue* queue, gpointer data, GCompareDataFunc func, gpointer user_data);			
    alias da_g_async_queue_pop = gpointer function(GAsyncQueue* queue);																					
    alias da_g_async_queue_pop_unlocked = gpointer function(GAsyncQueue* queue);																		
    alias da_g_async_queue_try_pop = gpointer function(GAsyncQueue* queue);																				
    alias da_g_async_queue_try_pop_unlocked = gpointer function(GAsyncQueue* queue);																	
    alias da_g_async_queue_timeout_pop = gpointer function(GAsyncQueue* queue, guint64 timeout);														
    alias da_g_async_queue_timeout_pop_unlocked = gpointer function(GAsyncQueue* queue, guint64 timeout);												
    alias da_g_async_queue_length = gint function(GAsyncQueue* queue);																					
    alias da_g_async_queue_length_unlocked = gint function(GAsyncQueue* queue);																			
    alias da_g_async_queue_sort = void function(GAsyncQueue* queue, GCompareDataFunc func, gpointer user_data);											
    alias da_g_async_queue_sort_unlocked = void function(GAsyncQueue* queue, GCompareDataFunc func, gpointer user_data);								
    alias da_g_async_queue_timed_pop = gpointer function(GAsyncQueue* queue, GTimeVal* end_time);														
    alias da_g_async_queue_timed_pop_unlocked = gpointer function(GAsyncQueue* queue, GTimeVal* end_time);												
}

__gshared 
{
    da_g_async_queue_new g_async_queue_new; 
    da_g_async_queue_new_full g_async_queue_new_full; 
    da_g_async_queue_lock g_async_queue_lock; 
    da_g_async_queue_unlock g_async_queue_unlock; 
    da_g_async_queue_ref g_async_queue_ref; 
    da_g_async_queue_unref g_async_queue_unref; 
    da_g_async_queue_ref_unlocked g_async_queue_ref_unlocked; 
    da_g_async_queue_unref_and_unlock g_async_queue_unref_and_unlock; 
    da_g_async_queue_push g_async_queue_push; 
    da_g_async_queue_push_unlocked g_async_queue_push_unlocked; 
    da_g_async_queue_push_sorted g_async_queue_push_sorted; 
    da_g_async_queue_push_sorted_unlocked g_async_queue_push_sorted_unlocked; 
    da_g_async_queue_pop g_async_queue_pop; 
    da_g_async_queue_pop_unlocked g_async_queue_pop_unlocked; 
    da_g_async_queue_try_pop g_async_queue_try_pop; 
    da_g_async_queue_try_pop_unlocked g_async_queue_try_pop_unlocked; 
    da_g_async_queue_timeout_pop g_async_queue_timeout_pop; 
    da_g_async_queue_timeout_pop_unlocked g_async_queue_timeout_pop_unlocked; 
    da_g_async_queue_length g_async_queue_length; 
    da_g_async_queue_length_unlocked g_async_queue_length_unlocked; 
    da_g_async_queue_sort g_async_queue_sort; 
    da_g_async_queue_sort_unlocked g_async_queue_sort_unlocked; 
    da_g_async_queue_timed_pop g_async_queue_timed_pop; 
    da_g_async_queue_timed_pop_unlocked g_async_queue_timed_pop_unlocked; 
}