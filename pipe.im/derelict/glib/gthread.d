/*

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*/ 

module derelict.glib.gthread;

import derelict.glib.gtypes;
import derelict.glib.glibconfig;
import derelict.glib.gquark;
import derelict.glib.gerror;
import core.stdc.config;

extern (C):

alias _Anonymous_0 GThreadError;
alias void* function (void*) GThreadFunc;
alias _GThread GThread;
alias _GMutex GMutex;
alias _GRecMutex GRecMutex;
alias _GRWLock GRWLock;
alias _GCond GCond;
alias _GPrivate GPrivate;
alias _GOnce GOnce;
alias _Anonymous_1 GOnceStatus;

enum _Anonymous_0
{
	G_THREAD_ERROR_AGAIN = 0
}

enum _Anonymous_1
{
	G_ONCE_STATUS_NOTCALLED = 0,
	G_ONCE_STATUS_PROGRESS = 1,
	G_ONCE_STATUS_READY = 2
}

struct _GRWLock
{
	gpointer p;
	guint[2] i;
}

struct _GCond
{
	gpointer p;
	guint[2] i;
}

struct _GRecMutex
{
	gpointer p;
	guint[2] i;
}

struct _GPrivate
{
	gpointer p;
	GDestroyNotify notify;
	gpointer[2] future;
}

struct _GOnce
{
	GOnceStatus status;
	gpointer retval;
}

struct _GThread;


//union _GMutex;


union _GMutex
{
	gpointer p;
	guint[2] i;
}



extern( C ) nothrow 
{
    alias da_g_thread_error_quark = GQuark function();																						
    alias da_g_thread_ref = GThread* function(GThread* thread);																				
    alias da_g_thread_unref = void function(GThread* thread);																				
    alias da_g_thread_new = GThread* function(const(gchar)* name, GThreadFunc func, gpointer data);											
    alias da_g_thread_try_new = GThread* function(const(gchar)* name, GThreadFunc func, gpointer data, GError** error);						
    alias da_g_thread_self = GThread* function();																							
    alias da_g_thread_exit = void function(gpointer retval);																				
    alias da_g_thread_join = gpointer function(GThread* thread);																			
    alias da_g_thread_yield = void function();																								
    alias da_g_mutex_init = void function(GMutex* mutex);																					
    alias da_g_mutex_clear = void function(GMutex* mutex);																					
    alias da_g_mutex_lock = void function(GMutex* mutex);																					
    alias da_g_mutex_trylock = gboolean function(GMutex* mutex);																			
    alias da_g_mutex_unlock = void function(GMutex* mutex);																					
    alias da_g_rw_lock_init = void function(GRWLock* rw_lock);																				
    alias da_g_rw_lock_clear = void function(GRWLock* rw_lock);																				
    alias da_g_rw_lock_writer_lock = void function(GRWLock* rw_lock);																		
    alias da_g_rw_lock_writer_trylock = gboolean function(GRWLock* rw_lock);																
    alias da_g_rw_lock_writer_unlock = void function(GRWLock* rw_lock);																		
    alias da_g_rw_lock_reader_lock = void function(GRWLock* rw_lock);																		
    alias da_g_rw_lock_reader_trylock = gboolean function(GRWLock* rw_lock);																
    alias da_g_rw_lock_reader_unlock = void function(GRWLock* rw_lock);																		
    alias da_g_rec_mutex_init = void function(GRecMutex* rec_mutex);																		
    alias da_g_rec_mutex_clear = void function(GRecMutex* rec_mutex);																		
    alias da_g_rec_mutex_lock = void function(GRecMutex* rec_mutex);																		
    alias da_g_rec_mutex_trylock = gboolean function(GRecMutex* rec_mutex);																	
    alias da_g_rec_mutex_unlock = void function(GRecMutex* rec_mutex);																		
    alias da_g_cond_init = void function(GCond* cond);																						
    alias da_g_cond_clear = void function(GCond* cond);																						
    alias da_g_cond_wait = void function(GCond* cond, GMutex* mutex);																		
    alias da_g_cond_signal = void function(GCond* cond);																					
    alias da_g_cond_broadcast = void function(GCond* cond);																					
    alias da_g_cond_wait_until = gboolean function(GCond* cond, GMutex* mutex, gint64 end_time);											
    alias da_g_private_get = gpointer function(GPrivate* key);																				
    alias da_g_private_set = void function(GPrivate* key, gpointer value);																	
    alias da_g_private_replace = void function(GPrivate* key, gpointer value);																
    alias da_g_once_impl = gpointer function(GOnce* once, GThreadFunc func, gpointer arg);													
    alias da_g_once_init_enter = gboolean function(void* location);																			
    alias da_g_once_init_leave = void function(void* location, gsize result);																
}

__gshared
{
    da_g_thread_error_quark g_thread_error_quark; 
    da_g_thread_ref g_thread_ref; 
    da_g_thread_unref g_thread_unref; 
    da_g_thread_new g_thread_new; 
    da_g_thread_try_new g_thread_try_new; 
    da_g_thread_self g_thread_self; 
    da_g_thread_exit g_thread_exit; 
    da_g_thread_join g_thread_join; 
    da_g_thread_yield g_thread_yield; 
    da_g_mutex_init g_mutex_init; 
    da_g_mutex_clear g_mutex_clear; 
    da_g_mutex_lock g_mutex_lock; 
    da_g_mutex_trylock g_mutex_trylock; 
    da_g_mutex_unlock g_mutex_unlock; 
    da_g_rw_lock_init g_rw_lock_init; 
    da_g_rw_lock_clear g_rw_lock_clear; 
    da_g_rw_lock_writer_lock g_rw_lock_writer_lock; 
    da_g_rw_lock_writer_trylock g_rw_lock_writer_trylock; 
    da_g_rw_lock_writer_unlock g_rw_lock_writer_unlock; 
    da_g_rw_lock_reader_lock g_rw_lock_reader_lock; 
    da_g_rw_lock_reader_trylock g_rw_lock_reader_trylock; 
    da_g_rw_lock_reader_unlock g_rw_lock_reader_unlock; 
    da_g_rec_mutex_init g_rec_mutex_init; 
    da_g_rec_mutex_clear g_rec_mutex_clear; 
    da_g_rec_mutex_lock g_rec_mutex_lock; 
    da_g_rec_mutex_trylock g_rec_mutex_trylock; 
    da_g_rec_mutex_unlock g_rec_mutex_unlock; 
    da_g_cond_init g_cond_init; 
    da_g_cond_clear g_cond_clear; 
    da_g_cond_wait g_cond_wait; 
    da_g_cond_signal g_cond_signal; 
    da_g_cond_broadcast g_cond_broadcast; 
    da_g_cond_wait_until g_cond_wait_until; 
    da_g_private_get g_private_get; 
    da_g_private_set g_private_set; 
    da_g_private_replace g_private_replace; 
    da_g_once_impl g_once_impl; 
    da_g_once_init_enter g_once_init_enter; 
    da_g_once_init_leave g_once_init_leave; 
}