/*

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*/
module derelict.glib.giochannel;

extern( C ) nothrow {
    alias da_NAME_FUNCTION = TYPE_RETURN function( TYPE_PARAMETER );
}

__gshared {
    da_NAME_FUNCTION NAME_FUNCTION;
}


/*


#if !defined (__GLIB_H_INSIDE__) && !defined (GLIB_COMPILATION)
#error "Only <glib.h> can be included directly."
#endif

#ifndef __G_IOCHANNEL_H__
#define __G_IOCHANNEL_H__

#include <glib/gconvert.h>
#include <glib/gmain.h>
#include <glib/gstring.h>

G_BEGIN_DECLS


typedef struct _GIOChannel	GIOChannel;
typedef struct _GIOFuncs        GIOFuncs;

typedef enum
{
    G_IO_ERROR_NONE,
        G_IO_ERROR_AGAIN,
        G_IO_ERROR_INVAL,
        G_IO_ERROR_UNKNOWN
} GIOError;

#define G_IO_CHANNEL_ERROR g_io_channel_error_quark()

typedef enum
{
    G_IO_CHANNEL_ERROR_FBIG,
        G_IO_CHANNEL_ERROR_INVAL,
        G_IO_CHANNEL_ERROR_IO,
        G_IO_CHANNEL_ERROR_ISDIR,
        G_IO_CHANNEL_ERROR_NOSPC,
        G_IO_CHANNEL_ERROR_NXIO,
        G_IO_CHANNEL_ERROR_OVERFLOW,
        G_IO_CHANNEL_ERROR_PIPE,
        G_IO_CHANNEL_ERROR_FAILED
} GIOChannelError;

typedef enum
{
    G_IO_STATUS_ERROR,
        G_IO_STATUS_NORMAL,
        G_IO_STATUS_EOF,
        G_IO_STATUS_AGAIN
} GIOStatus;

typedef enum
{
    G_SEEK_CUR,
        G_SEEK_SET,
        G_SEEK_END
} GSeekType;

{
    G_IO_IN	GLIB_SYSDEF_POLLIN,
        G_IO_OUT	GLIB_SYSDEF_POLLOUT,
        G_IO_PRI	GLIB_SYSDEF_POLLPRI,
        G_IO_ERR	GLIB_SYSDEF_POLLERR,
        G_IO_HUP	GLIB_SYSDEF_POLLHUP,
        G_IO_NVAL	GLIB_SYSDEF_POLLNVAL
} GIOCondition;

typedef enum
{
    G_IO_FLAG_APPEND = 1 << 0,
        G_IO_FLAG_NONBLOCK = 1 << 1,
        G_IO_FLAG_IS_READABLE = 1 << 2,	
        G_IO_FLAG_IS_WRITABLE = 1 << 3,	
        G_IO_FLAG_IS_SEEKABLE = 1 << 4,	
        G_IO_FLAG_MASK = (1 << 5) - 1,
        G_IO_FLAG_GET_MASK = G_IO_FLAG_MASK,
        G_IO_FLAG_SET_MASK = G_IO_FLAG_APPEND | G_IO_FLAG_NONBLOCK
} GIOFlags;

#define G_IO_FLAG_IS_WRITEABLE (G_IO_FLAG_IS_WRITABLE)

struct _GIOChannel
{
    gint ref_count;
    GIOFuncs *funcs;

    gchar *encoding;
    GIConv read_cd;
    GIConv write_cd;
    gchar *line_term;		
    guint line_term_len;	

    gsize buf_size;
    GString *read_buf;		
    GString *encoded_read_buf;  
    GString *write_buf;		
    gchar partial_write_buf[6];	


    guint use_buffer     : 1;	
    guint do_encode      : 1;	
    guint close_on_unref : 1;	
    guint is_readable    : 1;	
    guint is_writeable   : 1;	
    guint is_seekable    : 1;	

    gpointer reserved1;	
    gpointer reserved2;	
};

typedef gboolean (*GIOFunc) (GIOChannel   *source,
                             GIOCondition  condition,
                             gpointer      data);
struct _GIOFuncs
{
    GIOStatus (*io_read)           (GIOChannel   *channel, 
                                    gchar        *buf, 
                                    gsize         count,
                                    gsize        *bytes_read,
                                    GError      **err);
    GIOStatus (*io_write)          (GIOChannel   *channel, 
                                    const gchar  *buf, 
                                    gsize         count,
                                    gsize        *bytes_written,
                                    GError      **err);
    GIOStatus (*io_seek)           (GIOChannel   *channel, 
                                    gint64        offset, 
                                    GSeekType     type,
                                    GError      **err);
    GIOStatus  (*io_close)         (GIOChannel   *channel,
                                    GError      **err);
    GSource*   (*io_create_watch)  (GIOChannel   *channel,
                                    GIOCondition  condition);
    void       (*io_free)          (GIOChannel   *channel);
    GIOStatus  (*io_set_flags)     (GIOChannel   *channel,
                                    GIOFlags      flags,
                                    GError      **err);
    GIOFlags   (*io_get_flags)     (GIOChannel   *channel);
};

void        g_io_channel_init   (GIOChannel    *channel);
GIOChannel *g_io_channel_ref    (GIOChannel    *channel);
void        g_io_channel_unref  (GIOChannel    *channel);

GLIB_DEPRECATED_FOR(g_io_channel_read_for)
GIOError    g_io_channel_read   (GIOChannel    *channel,
                                 gchar         *buf,
                                 gsize          count,
                                 gsize         *bytes_read);

GLIB_DEPRECATED_FOR(g_io_channel_write_chars)
GIOError  g_io_channel_write    (GIOChannel    *channel,
                                 const gchar   *buf,
                                 gsize          count,
                                 gsize         *bytes_written);

GLIB_DEPRECATED_FOR(g_io_channel_seek_position)
GIOError  g_io_channel_seek     (GIOChannel    *channel,
                                 gint64         offset,
                                 GSeekType      type);

GLIB_DEPRECATED_FOR(g_io_channel_shutdown)
void      g_io_channel_close    (GIOChannel    *channel);

GIOStatus g_io_channel_shutdown (GIOChannel      *channel,
                                 gboolean         flush,
                                 GError         **err);
guint     g_io_add_watch_full   (GIOChannel      *channel,
                                 gint             priority,
                                 GIOCondition     condition,
                                 GIOFunc          func,
                                 gpointer         user_data,
                                 GDestroyNotify   notify);
GSource * g_io_create_watch     (GIOChannel      *channel,
                                 GIOCondition     condition);
guint     g_io_add_watch        (GIOChannel      *channel,
                                 GIOCondition     condition,
                                 GIOFunc          func,
                                 gpointer         user_data);

void                  g_io_channel_set_buffer_size      (GIOChannel   *channel,
                                                         gsize         size);
gsize                 g_io_channel_get_buffer_size      (GIOChannel   *channel);
GIOCondition          g_io_channel_get_buffer_condition (GIOChannel   *channel);
GIOStatus             g_io_channel_set_flags            (GIOChannel   *channel,
                                                         GIOFlags      flags,
                                                         GError      **error);
GIOFlags              g_io_channel_get_flags            (GIOChannel   *channel);
void                  g_io_channel_set_line_term        (GIOChannel   *channel,
                                                         const gchar  *line_term,
                                                         gint          length);
const gchar *         g_io_channel_get_line_term        (GIOChannel   *channel,
                                                         gint         *length);
void		      g_io_channel_set_buffered		(GIOChannel   *channel,
                                                 gboolean      buffered);
gboolean	      g_io_channel_get_buffered		(GIOChannel   *channel);
GIOStatus             g_io_channel_set_encoding         (GIOChannel   *channel,
                                                         const gchar  *encoding,
                                                         GError      **error);
const gchar *         g_io_channel_get_encoding         (GIOChannel   *channel);
void                  g_io_channel_set_close_on_unref	(GIOChannel   *channel,
                                                         gboolean      do_close);
gboolean              g_io_channel_get_close_on_unref	(GIOChannel   *channel);


GIOStatus   g_io_channel_flush            (GIOChannel   *channel,
                                           GError      **error);
GIOStatus   g_io_channel_read_line        (GIOChannel   *channel,
                                           gchar       **str_return,
                                           gsize        *length,
                                           gsize        *terminator_pos,
                                           GError      **error);
GIOStatus   g_io_channel_read_line_string (GIOChannel   *channel,
                                           GString      *buffer,
                                           gsize        *terminator_pos,
                                           GError      **error);
GIOStatus   g_io_channel_read_to_end      (GIOChannel   *channel,
                                           gchar       **str_return,
                                           gsize        *length,
                                           GError      **error);
GIOStatus   g_io_channel_read_chars       (GIOChannel   *channel,
                                           gchar        *buf,
                                           gsize         count,
                                           gsize        *bytes_read,
                                           GError      **error);
GIOStatus   g_io_channel_read_unichar     (GIOChannel   *channel,
                                           gunichar     *thechar,
                                           GError      **error);
GIOStatus   g_io_channel_write_chars      (GIOChannel   *channel,
                                           const gchar  *buf,
                                           gssize        count,
                                           gsize        *bytes_written,
                                           GError      **error);
GIOStatus   g_io_channel_write_unichar    (GIOChannel   *channel,
                                           gunichar      thechar,
                                           GError      **error);
GIOStatus   g_io_channel_seek_position    (GIOChannel   *channel,
                                           gint64        offset,
                                           GSeekType     type,
                                           GError      **error);
#ifdef G_OS_WIN32
#define g_io_channel_new_file g_io_channel_new_file_utf8
#endif

GIOChannel* g_io_channel_new_file         (const gchar  *filename,
                                           const gchar  *mode,
                                           GError      **error);



GQuark          g_io_channel_error_quark      (void);
GIOChannelError g_io_channel_error_from_errno (gint en);

GIOChannel* g_io_channel_unix_new    (int         fd);
gint        g_io_channel_unix_get_fd (GIOChannel *channel);


GLIB_VAR GSourceFuncs g_io_watch_funcs;

#ifdef G_OS_WIN32

#define G_WIN32_MSG_HANDLE 19981206

void        g_io_channel_win32_make_pollfd (GIOChannel   *channel,
                                            GIOCondition  condition,
                                            GPollFD      *fd);

gint        g_io_channel_win32_poll   (GPollFD    *fds,
                                       gint        n_fds,
                                       gint        timeout_);

#if GLIB_SIZEOF_VOID_P == 8
GIOChannel *g_io_channel_win32_new_messages (gsize hwnd);
#else
GIOChannel *g_io_channel_win32_new_messages (guint hwnd);
#endif

GIOChannel* g_io_channel_win32_new_fd (gint         fd);

gint        g_io_channel_win32_get_fd (GIOChannel *channel);

GIOChannel *g_io_channel_win32_new_socket (gint socket);

#endif

G_END_DECLS



*/