/*

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*/ 

module derelict.glib.ghook;

import derelict.glib.gtypes;
import derelict.glib.glibconfig;

extern (C):

alias _GHook GHook;
alias _GHookList GHookList;
alias int function (_GHook*, _GHook*) GHookCompareFunc;
alias int function (_GHook*, void*) GHookFindFunc;
alias void function (_GHook*, void*) GHookMarshaller;
alias int function (_GHook*, void*) GHookCheckMarshaller;
alias void function (void*) GHookFunc;
alias int function (void*) GHookCheckFunc;
alias void function (_GHookList*, _GHook*) GHookFinalizeFunc;
alias _Anonymous_0 GHookFlagMask;

enum _Anonymous_0
{
	G_HOOK_FLAG_ACTIVE = 1,
	G_HOOK_FLAG_IN_CALL = 2,
	G_HOOK_FLAG_MASK = 15
}

struct _GHookList
{
	gulong seq_id;
	guint hook_size;
	guint is_setup;
	GHook* hooks;
	gpointer dummy3;
	GHookFinalizeFunc finalize_hook;
	gpointer[2] dummy;
}

struct _GHook
{
	gpointer data;
	GHook* next;
	GHook* prev;
	guint ref_count;
	gulong hook_id;
	guint flags;
	gpointer func;
	GDestroyNotify destroy;
}

extern( C ) nothrow 
{
    alias da_g_hook_list_init = void function(GHookList* hook_list, guint hook_size);																					
    alias da_g_hook_list_clear = void function(GHookList* hook_list);																									
    alias da_g_hook_alloc = GHook* function(GHookList* hook_list);																										
    alias da_g_hook_free = void function(GHookList* hook_list, GHook* hook);																							
    alias da_g_hook_ref = GHook* function(GHookList* hook_list, GHook* hook);																							
    alias da_g_hook_unref = void function(GHookList* hook_list, GHook* hook);																							
    alias da_g_hook_destroy = gboolean function(GHookList* hook_list, gulong hook_id);																					
    alias da_g_hook_destroy_link = void function(GHookList* hook_list, GHook* hook);																					
    alias da_g_hook_prepend = void function(GHookList* hook_list, GHook* hook);																							
    alias da_g_hook_insert_before = void function(GHookList* hook_list, GHook* sibling, GHook* hook);																	
    alias da_g_hook_insert_sorted = void function(GHookList* hook_list, GHook* hook, GHookCompareFunc func);															
    alias da_g_hook_get = GHook* function(GHookList* hook_list, gulong hook_id);																						
    alias da_g_hook_find = GHook* function(GHookList* hook_list, gboolean need_valids, GHookFindFunc func, gpointer data);												
    alias da_g_hook_find_data = GHook* function(GHookList* hook_list, gboolean need_valids, gpointer data);																
    alias da_g_hook_find_func = GHook* function(GHookList* hook_list, gboolean need_valids, gpointer func);																
    alias da_g_hook_find_func_data = GHook* function(GHookList* hook_list, gboolean need_valids, gpointer func, gpointer data);											
    alias da_g_hook_first_valid = GHook* function(GHookList* hook_list, gboolean may_be_in_call);																		
    alias da_g_hook_next_valid = GHook* function(GHookList* hook_list, GHook* hook, gboolean may_be_in_call);															
    alias da_g_hook_compare_ids = gint function(GHook* new_hook, GHook* sibling);																						
    alias da_g_hook_list_invoke = void function(GHookList* hook_list, gboolean may_recurse);																			
    alias da_g_hook_list_invoke_check = void function(GHookList* hook_list, gboolean may_recurse);																		
    alias da_g_hook_list_marshal = void function(GHookList* hook_list, gboolean may_recurse, GHookMarshaller marshaller, gpointer marshal_data);						
    alias da_g_hook_list_marshal_check = void function(GHookList* hook_list, gboolean may_recurse, GHookCheckMarshaller marshaller, gpointer marshal_data);				
}

__gshared
{
    da_g_hook_list_init g_hook_list_init; 
    da_g_hook_list_clear g_hook_list_clear; 
    da_g_hook_alloc g_hook_alloc; 
    da_g_hook_free g_hook_free; 
    da_g_hook_ref g_hook_ref; 
    da_g_hook_unref g_hook_unref; 
    da_g_hook_destroy g_hook_destroy; 
    da_g_hook_destroy_link g_hook_destroy_link; 
    da_g_hook_prepend g_hook_prepend; 
    da_g_hook_insert_before g_hook_insert_before; 
    da_g_hook_insert_sorted g_hook_insert_sorted; 
    da_g_hook_get g_hook_get; 
    da_g_hook_find g_hook_find; 
    da_g_hook_find_data g_hook_find_data; 
    da_g_hook_find_func g_hook_find_func; 
    da_g_hook_find_func_data g_hook_find_func_data; 
    da_g_hook_first_valid g_hook_first_valid; 
    da_g_hook_next_valid g_hook_next_valid; 
    da_g_hook_compare_ids g_hook_compare_ids; 
    da_g_hook_list_invoke g_hook_list_invoke; 
    da_g_hook_list_invoke_check g_hook_list_invoke_check; 
    da_g_hook_list_marshal g_hook_list_marshal; 
    da_g_hook_list_marshal_check g_hook_list_marshal_check; 	
}




