/*

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*/ 

module derelict.glib.gnode;

import derelict.glib.gtypes;
import derelict.glib.glibconfig;

extern (C):

alias _GNode GNode;
alias _Anonymous_0 GTraverseFlags;
alias _Anonymous_1 GTraverseType;
alias int function (_GNode*, void*) GNodeTraverseFunc;
alias void function (_GNode*, void*) GNodeForeachFunc;
alias void* function (const(void)*, void*) GCopyFunc;

enum _Anonymous_0
{
	G_TRAVERSE_LEAVES = 1,
	G_TRAVERSE_NON_LEAVES = 2,
	G_TRAVERSE_ALL = 3,
	G_TRAVERSE_MASK = 3,
	G_TRAVERSE_LEAFS = 1,
	G_TRAVERSE_NON_LEAFS = 2
}

enum _Anonymous_1
{
	G_IN_ORDER = 0,
	G_PRE_ORDER = 1,
	G_POST_ORDER = 2,
	G_LEVEL_ORDER = 3
}

struct _GNode
{
	gpointer data;
	GNode* next;
	GNode* prev;
	GNode* parent;
	GNode* children;
}



extern( C ) nothrow 
{
	alias da_g_node_new = GNode* function(gpointer data);																											
    alias da_g_node_destroy = void function(GNode* root);																											
    alias da_g_node_unlink = void function(GNode* node);																											
    alias da_g_node_copy_deep = GNode* function(GNode* node, GCopyFunc copy_func, gpointer data);																	
    alias da_g_node_copy = GNode* function(GNode* node);																											
    alias da_g_node_insert = GNode* function(GNode* parent, gint position, GNode* node);																			
    alias da_g_node_insert_before = GNode* function(GNode* parent, GNode* sibling, GNode* node);																	
    alias da_g_node_insert_after = GNode* function(GNode* parent, GNode* sibling, GNode* node);																		
    alias da_g_node_prepend = GNode* function(GNode* parent, GNode* node);																							
    alias da_g_node_n_nodes = guint function(GNode* root, GTraverseFlags flags);																					
    alias da_g_node_get_root = GNode* function(GNode* node);																										
    alias da_g_node_is_ancestor = gboolean function(GNode* node, GNode* descendant);																				
    alias da_g_node_depth = guint function(GNode* node);																											
    alias da_g_node_find = GNode* function(GNode* root, GTraverseType order, GTraverseFlags flags, gpointer data);													
    alias da_g_node_traverse = void function(GNode* root, GTraverseType order, GTraverseFlags flags, gint max_depth, GNodeTraverseFunc func, gpointer data);		
    alias da_g_node_max_height = guint function(GNode* root);																										
    alias da_g_node_children_foreach = void function(GNode* node, GTraverseFlags flags, GNodeForeachFunc func, gpointer data);										
    alias da_g_node_reverse_children = void function(GNode* node);																									
    alias da_g_node_n_children = guint function(GNode* node);																										
    alias da_g_node_nth_child = GNode* function(GNode* node, guint n);																								
    alias da_g_node_last_child = GNode* function(GNode* node);																										
    alias da_g_node_find_child = GNode* function(GNode* node, GTraverseFlags flags, gpointer data);																	
    alias da_g_node_child_position = gint function(GNode* node, GNode* child);																						
    alias da_g_node_child_index = gint function(GNode* node, gpointer data);																						
    alias da_g_node_first_sibling = GNode* function(GNode* node);																									
    alias da_g_node_last_sibling = GNode* function(GNode* node);																									
}

__gshared
{
	da_g_node_new g_node_new; 
    da_g_node_destroy g_node_destroy; 
    da_g_node_unlink g_node_unlink; 
    da_g_node_copy_deep g_node_copy_deep; 
    da_g_node_copy g_node_copy; 
    da_g_node_insert g_node_insert; 
    da_g_node_insert_before g_node_insert_before; 
    da_g_node_insert_after g_node_insert_after; 
    da_g_node_prepend g_node_prepend; 
    da_g_node_n_nodes g_node_n_nodes; 
    da_g_node_get_root g_node_get_root; 
    da_g_node_is_ancestor g_node_is_ancestor; 
    da_g_node_depth g_node_depth; 
    da_g_node_find g_node_find; 
    da_g_node_traverse g_node_traverse; 
    da_g_node_max_height g_node_max_height; 
    da_g_node_children_foreach g_node_children_foreach; 
    da_g_node_reverse_children g_node_reverse_children; 
    da_g_node_n_children g_node_n_children; 
    da_g_node_nth_child g_node_nth_child; 
    da_g_node_last_child g_node_last_child; 
    da_g_node_find_child g_node_find_child; 
    da_g_node_child_position g_node_child_position; 
    da_g_node_child_index g_node_child_index; 
    da_g_node_first_sibling g_node_first_sibling; 
    da_g_node_last_sibling g_node_last_sibling; 
}







